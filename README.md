# FERRY_SERVICE_APPLICATION

4.1 Application Environment
For the sake of reusability, "hard-coded" elements should not occur in the program. Therefore, the file config.py was integrated as a central element for the configuration. This file serves as a kind of control center in which all important parameters, settings, variables, and configurations are centralized. Running processes in the application can then access the configuration file to extract relevant values.  This is intended to make the application adaptable to different scenarios, environments, and requirements without changing the source code of the application itself. The application consists of five steps, which are described in detail in the following sections. It is important to mention that each presented module can be executed independently using its respective module file (e.g. _1_demand_generation). However, to run the complete application process, which sequentially includes every module, including demand generation, route optimization, and result evaluation, it is necessary to run the main.py file located in the application folder.
4.1.1 Parameter Settings 
Before running the application, parameters and file paths for data input and data output must be defined in config.py. Parameters to be set either correspond to the parameters included in the mathematical formulation presented in Section 4.2 or to parameters required for defining the run process e.g. how many request instances are to be generated and optimized per run. An instance consists of n passengers. A set consists of m homogeneous instances. Homogeneous implies that instances of a set differ in data, but not in size or parameter settings. In each iteration, i.e. for each instance, the five process steps described in Section 5.2.1 to Section 5.2.5 are executed. Table 2 entails the most relevant parameters to be configured in the config file of the application. 

Parameter	Description
dt_DEPARTURE_TIME_SPAN	Upper limit of the time span, starting from 0, within which passenger departure times occur.
FERRY_VELOCITY  	Ferry velocity in meter per second (12km/h)
BIKING_VELOCITY	Cycling speed in km/h
BENCHMARK_CLEAN_REQUESTS
	Required time savings threshold to consider a  request valid
Model Parameters:
n_NUMBER_OF_PASSENGERS	Size of instance
d_SERVICE_TIMES   	Berthing and embarking time
K_FLEET_SIZE	Fleet size 
Q_CAPACITY  	Number of seats per ferry 
q_LOAD_PER_REQUEST 	Number of passengers traveling per request 
PENALTY_FACTOR   	Factor to determine weight of delays 
TK_MAX_RT_VEHICLE 	Maximal duration of route per ferry 
L_MAX_RT_PASSENGER      	Maximal ride-time per passenger 


Table 2. Parameters to be configured in the UAF-Service-Application

4.1.2 Technological Infrastructure and Visualization
The application was developed using Python 3.9.5 within the PyCharm IDE. For obtaining conventional routes along with travel times, the application utilized the Google Maps API. The input of demand polygons was managed through the use of Shapely. Data management was facilitated by the Panda framework and the SQLite3 database. Gurobipy, a Python-based API provided by Gurobi, served as the mathematical solver for route optimization. To visualize passenger requests and their corresponding station assignments, a frontend component was integrated into the application. This component can be locally hosted by executing the file helper/visualize_requests.py after running the application, irrespective of the optimization success. The visualization involves an HTML file incorporating a comprehensive JavaScript script, leveraging the Google Maps API to dynamically display ferry stations and requests on a map. After successful optimization runs, the application generates tables and line plot graphics to visualize obtained results. This visualization is achieved using the Matplotlib library.
4.2 Application Process
The application comprises five phases, each of which can function as standalone modules. Phases 1, 2, and 3 are designed for generating test data for the optimization model. Consequently, these phases can be omitted from the process when the application is utilized with readily available real-world data. Figure X roughly illustrated the process design, while the individual phases are briefly described in the following sections. 

 
Figure 9. Application Modules
4.2.1 Demand Generation
To simulate a specific application scenario, the initial input shall consist of (1) the coordinates of the ferry stations available in the service and (2) a minimum of two demand polygons. These polygons specify the areas where the starting or ending points of requests can be found, and they are defined by the coordinates of their vertices. Figure 10 Illustrative excerpts of the use case area in Duesseldorf before applying the initial input on the left and after implementing coordinates of ferry stations and two demand polygons, marked in green. 

   
Figure 10. Specified Use Case Area

The parameter n_NUMBER_OF_PASSENGERS hosted in the config.py file of the application determines the quantity of passenger requests produced for each instance. In this process, n random coordinates are selected from each of the two polygons. Subsequently, a coordinate from the right-side polygon is matched with a coordinate from the left-side polygon. This yields a request in which the starting point is situated in a distinct polygon from the destination point, signifying a request that involves crossing a river. Moreover, each request is assigned a random value within the time frame commencing at 0 and constrained by the configured value dt_DEPARTURE_TIME_SPAN. Every passenger of an instance leaves his or her starting point within this specified range. The smaller the time span is set, the more simultaneous requests are likely to occur in an instance of passenger requests. Further, the Google Maps API is used to obtain the conventional route including the corresponding travel time for each request, which is later used as a benchmark in determining the passenger's time-windows for the ferry service. To simulate targeted scenarios in the absence of empirical data more accurately, demand polygons could also be clustered, as it is also possible to entail more than two demand polygons. 
4.2.2 Station Assignment
Finding the best ferry stations to assign to start and destination location has a significant impact on the efficiency of the UAF-Service. For every request, there are two stations to assign: a pickup station, and a drop-off station. The assignment is entirely based on distance. However, there are two possible approaches: (1) minimizing the distance on land, i.e. the distance between stations and passenger locations or (2) minimizing the distance on water. Figure 11 illustrates both approaches in comparison with (a) representing station assignment with minimized land distance. 

  
(a)						    (b)
Figure 11. Comparing Station Assignments 

For the specific application in this study, it has been observed that variant (b) consistently produces significantly improved results. Nevertheless, the code supplied also offers the flexibility to implement variant (a), which might be more appropriate for different geographical scenarios. The primary objective of this assignment process is to minimize the overall distance between the request's start and destination points, considering the route as a whole rather than individual segments. If the selection of the nearest pickup station is based solely on the shortest distance to the initial starting point, there is a possibility that this chosen pickup station may be farther away from the final destination than another station (such as the second closest station) that is closer to the destination. Therefore, the station assignment is conducted in a manner that compromises the distances of the sub-routes: Let point A be the starting point of a request. To assign a pickup station to point A, it is initially determined in which polygon (on which side of the river) Point A is located. If point A is located on the right side, a distance matrix is generated, which connects point A to all stations located on the same right side. From this one-dimensional matrix, the indices of the three smallest values are declared as choice of pickup stations. The selection of the pickup station should strike a balance between being as close as possible to the starting point while also being situated in the direction of the destination. To accomplish this, a one-dimensional distance matrix is established between the passenger's destination point and the choice of pickup stations. The pickup station with the shortest distance among the three preselected options is designated as the final choice. The determination of the destination station follows a similar procedure.

Route distances are typically obtained using route planning software throughout this work. However, since many stations in this use case are located in areas without dedicated pedestrian or bike infrastructure, distances calculated by Google Maps may be higher than actual distances, as it considers only existing bike lanes. Consequently, subroutes A and C are based on Euclidean distances in the current stage.
 
4.2.3 Clean Requests
This step is used to exclude dispensable requests. All previously created requests (including the station assignments) are now checked for validity. A request is only considered valid if the minimum possible time for the ferry route (minimum ferry time) is shorter than the travel time of the conventional route. The minimum ferry time results from a scenario in which a passenger is picked up immediately after arrival at their pick-up station and transported directly, i.e. without ride-sharing, to their drop-off station. The benchmark for this procedure is configurable and determines the size of the time-windows. For example, if the benchmark parameter is set to 3, the minimum ferry route, including the loading time, must be at least 3 minutes shorter than the conventional route.
4.2.4 Optimize Routes
An initial distance matrix, encompassing all stations within the ferry service, is provided. For each request instance, a new distance matrix is generated based on this initial matrix, with its indices aligning with the order of the stations in V = {depot, P, D, depot}. To guarantee that the model treats each point within V as unique, even in cases where stations may overlap, the model employs V_ as an encapsulation of V. V_ replaces the actual stations with a numerical sequence ranging from 0 to n. Consider a scenario where n = 2 passengers are picked up from Station 3, with one of them requiring transportation to Station 7 and the other to Station 5. As a result, the sequence V = [0, 3, 3, 7, 5, 0] is obtained. The indices in the newly created distance matrix correspond to this V sequence, with identical stations having a distance of 0 from each other. Subsequently, each index enables access to the corresponding position in the newly formed distance matrix, where the order aligns with the actual stations in V.

Determining of Time-Windows at Stations
A time window, represented as  , specifies the allowable time frame at during which a passenger must be served, with   indicating the earliest service start time and   as the latest service end time. Each pickup and drop-off station assigned to a request is associated with a specific time window, ensuring that the ferry route's arrival time is at least as early as that of the arrival time resulting from the conventional route. When using common route planning software, either the departure or arrival time is typically defined. This holds true in this scenario as well: the passenger specifies a departure time when they leave their original starting point. Based on the departure time, the conventional arrival time at the destination is determined. This also enables the determination of when the passenger will arrive at their pickup station at the earliest, which is referred to as the earliest start of service at the pickup station. 

For this use-case, the time window of a requestâ€™s pickup station and drop-off station are identical, although in many applications of the DARP, time windows at pickup stations differ from those at their associated drop-off stations. In the context of medical transport, there is often a critical need to pick up passengers within a designated time frame to ensure they receive timely assistance. Similarly, in the transportation of goods, variations in opening hours at different locations result in unique time constraints for both pickup and drop-off points. In the context of this service however, passengers do not benefit from having smaller pickup time windows compared to their drop-off time windows, as it could lead to potentially spending more time on board of the ferries without any added advantages. Given this context, the two time windows are defined as follows: The earliest start of service   corresponds to the earliest time at which a passenger reaches their pickup station and is determined by adding the departure time   to the travel time of subroute A    (the time required to travel by bicycle from the passenger's starting point to the assigned pickup station). The latest start of service   is obtained by subtracting the conventional arrival time    from the travel time   of subroute C (the time required to travel from the assigned drop-off station to the passenger's destination). Summing up, the resulting time window     is determined by
   		and 		 . 
Fig. 11 illustrates this procedure, where each   is represented in minutes, while   and   denote actual time points.   and   are the resulting time windows at the assigned stations.

 
Figure 12. Resulting Time-Windows

In alignment with the mathematical formulation presented in Section 3, the service must not commence under any circumstances before the earliest start time of the service  . Assigned ferries are required to wait until the time window opens in case of early arrival at the pickup station. Delays, or violations of the latest start time of service  , however, are permissible but may incur penalties.
4.2.5 Result Evaluation
At the end of each optimization, the data series are appended to a CSV file. Subsequently, at the conclusion of each application run, this CSV file is transferred into an SQLite3 database, enabling targeted querying of results in subsequent analyses. An illustrative data table is provided in the appendix, along with the corresponding SQL queries that generate the average results depicted in Section 5.4. In addition to the tables presented in Section 5.4, the appendix also includes figures that visually enhance the interpretation of the results through line plots. The Matplotlib library, in conjunction with Panda, was employed for this purpose. The detailed process of result obtainment is outlined in the main.py file of the application. In this file, configurations are first set before initiating the application run, which includes optimization steps and the retrieval of results.
